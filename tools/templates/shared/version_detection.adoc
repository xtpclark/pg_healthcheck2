=== Version Detection (MANDATORY)

All connectors MUST implement version detection to enable version-aware health checks and feature detection.

==== Required Methods

Every connector MUST implement:

[source,python]
----
def _get_version_info(self):
    """
    Detects database version and returns metadata.
    
    MUST return dict with:
    - 'version_string': str (full version string from database)
    - 'major_version': int (major version number)
    - Technology-specific boolean flags (e.g., 'is_pg14_or_newer')
    - Any additional relevant metadata
    
    Returns:
        dict: Version information
    """
    pass

@property
def version_info(self):
    """Returns cached version information."""
    if self._version_info is None:
        self._version_info = self._get_version_info()
    return self._version_info
----

==== Version Detection Patterns by Technology

===== PostgreSQL

**Version String Formats:**
- `"PostgreSQL 17.2 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 11.2.0, 64-bit"`
- `"PostgreSQL 14.10 (Ubuntu 14.10-1.pgdg22.04+1) on x86_64-pc-linux-gnu"`
- `"PostgreSQL 9.6.24 on x86_64-pc-linux-gnu"`

**Version Number:** Integer format (e.g., 170002 for 17.0.2)

**Implementation:**
[source,python]
----
def _get_version_info(self):
    """Detects PostgreSQL version."""
    try:
        self.cursor.execute("SELECT current_setting('server_version_num');")
        version_num = int(self.cursor.fetchone()[0].strip())
        
        self.cursor.execute("SELECT current_setting('server_version');")
        version_string = self.cursor.fetchone()[0].strip()
        
        major_version = version_num // 10000
        
        return {
            'version_num': version_num,
            'version_string': version_string,
            'major_version': major_version,
            'is_pg10_or_newer': major_version >= 10,
            'is_pg11_or_newer': major_version >= 11,
            'is_pg12_or_newer': major_version >= 12,
            'is_pg13_or_newer': major_version >= 13,
            'is_pg14_or_newer': major_version >= 14,
            'is_pg15_or_newer': major_version >= 15,
            'is_pg16_or_newer': major_version >= 16,
            'is_pg17_or_newer': major_version >= 17,
        }
    except Exception as e:
        logger.warning(f"Could not detect PostgreSQL version: {e}")
        return {
            'version_num': 0,
            'version_string': 'Unknown',
            'major_version': 0,
            'is_pg10_or_newer': False,
            'is_pg12_or_newer': False,
            'is_pg14_or_newer': False,
            'is_pg15_or_newer': False,
            'is_pg17_or_newer': False,
        }
----

**Key Milestones:**
- **PostgreSQL 10+**: Changed version numbering from 9.x to 10.x
- **PostgreSQL 12+**: Major performance improvements, B-tree deduplication
- **PostgreSQL 14+**: Logical replication improvements, multi-range types
- **PostgreSQL 15+**: MERGE statement, improved compression
- **PostgreSQL 17+**: Incremental backup, improved vacuum

===== Cassandra

**Version String Formats:**
- `"4.1.3"`
- `"3.11.14"`
- `"5.0-beta1"`

**Implementation:**
[source,python]
----
def _get_version_info(self):
    """Detects Cassandra version."""
    try:
        rows = self.session.execute("SELECT release_version FROM system.local")
        version_string = rows[0]['release_version'] if rows else 'Unknown'
        
        # Parse version string (e.g., "4.1.3" or "5.0-beta1")
        import re
        match = re.match(r'(\d+)\.(\d+)', version_string)
        if match:
            major = int(match.group(1))
            minor = int(match.group(2))
        else:
            major, minor = 0, 0
        
        return {
            'version_string': version_string,
            'major_version': major,
            'minor_version': minor,
            'is_v3_or_newer': major >= 3,
            'is_v3_11_or_newer': major > 3 or (major == 3 and minor >= 11),
            'is_v4_or_newer': major >= 4,
            'is_v4_1_or_newer': major > 4 or (major == 4 and minor >= 1),
            'is_v5_or_newer': major >= 5,
        }
    except Exception as e:
        logger.warning(f"Could not detect Cassandra version: {e}")
        return {
            'version_string': 'Unknown',
            'major_version': 0,
            'minor_version': 0,
            'is_v3_or_newer': False,
            'is_v4_or_newer': False,
            'is_v5_or_newer': False,
        }
----

**Key Milestones:**
- **Cassandra 3.11+**: Last 3.x stable release, widely deployed
- **Cassandra 4.0+**: Virtual tables, audit logging, transient replication
- **Cassandra 4.1+**: Guardrails, improved streaming
- **Cassandra 5.0+**: Storage engine improvements, CEP support

===== MongoDB

**Version String Formats:**
- `"7.0.4"`
- `"6.0.12"`
- `"5.0.23"`
- `"4.4.27"`

**Implementation:**
[source,python]
----
def _get_version_info(self):
    """Detects MongoDB version."""
    try:
        build_info = self.client.admin.command('buildInfo')
        version_string = build_info.get('version', 'Unknown')
        
        # Parse semantic version
        parts = version_string.split('.')
        major = int(parts[0]) if len(parts) > 0 else 0
        minor = int(parts[1]) if len(parts) > 1 else 0
        patch = int(parts[2]) if len(parts) > 2 else 0
        
        return {
            'version_string': version_string,
            'major_version': major,
            'minor_version': minor,
            'patch_version': patch,
            'is_v4_or_newer': major >= 4,
            'is_v4_2_or_newer': major > 4 or (major == 4 and minor >= 2),
            'is_v4_4_or_newer': major > 4 or (major == 4 and minor >= 4),
            'is_v5_or_newer': major >= 5,
            'is_v6_or_newer': major >= 6,
            'is_v7_or_newer': major >= 7,
        }
    except Exception as e:
        logger.warning(f"Could not detect MongoDB version: {e}")
        return {
            'version_string': 'Unknown',
            'major_version': 0,
            'minor_version': 0,
            'is_v4_or_newer': False,
            'is_v5_or_newer': False,
            'is_v6_or_newer': False,
            'is_v7_or_newer': False,
        }
----

**Key Milestones:**
- **MongoDB 4.0+**: Multi-document ACID transactions
- **MongoDB 4.2+**: Distributed transactions, wildcard indexes
- **MongoDB 4.4+**: Hedged reads, refinable shard keys
- **MongoDB 5.0+**: Time series collections, native time series
- **MongoDB 6.0+**: Queryable encryption
- **MongoDB 7.0+**: Improved change streams, query performance

===== ClickHouse

**Version String Formats:**
- `"24.1.2.5"`
- `"23.8.9.54"`
- `"22.3.20.29"`

**Implementation:**
[source,python]
----
def _get_version_info(self):
    """Detects ClickHouse version."""
    try:
        result = self.client.execute("SELECT version()")
        version_string = result[0][0] if result else 'Unknown'
        
        # Parse ClickHouse version format: YEAR.MONTH.PATCH.BUILD
        parts = version_string.split('.')
        year = int(parts[0]) if len(parts) > 0 else 0
        month = int(parts[1]) if len(parts) > 1 else 0
        patch = int(parts[2]) if len(parts) > 2 else 0
        
        # Create comparable version number
        version_num = (year * 100) + month
        
        return {
            'version_string': version_string,
            'year': year,
            'month': month,
            'patch': patch,
            'version_num': version_num,
            'is_v21_or_newer': year >= 21,
            'is_v22_or_newer': year >= 22,
            'is_v23_or_newer': year >= 23,
            'is_v23_8_or_newer': version_num >= 2308,
            'is_v24_or_newer': year >= 24,
        }
    except Exception as e:
        logger.warning(f"Could not detect ClickHouse version: {e}")
        return {
            'version_string': 'Unknown',
            'year': 0,
            'month': 0,
            'version_num': 0,
            'is_v22_or_newer': False,
            'is_v23_or_newer': False,
            'is_v24_or_newer': False,
        }
----

**Key Milestones:**
- **ClickHouse 21.x**: First LTS release series
- **ClickHouse 22.x**: Improved JOIN performance, sparse index
- **ClickHouse 23.x**: Lightweight deletes, improved projections
- **ClickHouse 23.8+**: Analyzer improvements (major query planner rewrite)
- **ClickHouse 24.x**: Native JSON type, query cache improvements

===== OpenSearch

**Version String Formats:**
- `"2.11.1"`
- `"2.9.0"`
- `"1.3.14"`

**Implementation:**
[source,python]
----
def _get_version_info(self):
    """Detects OpenSearch version."""
    try:
        info = self.client.info()
        version_info = info.get('version', {})
        version_string = version_info.get('number', 'Unknown')
        distribution = version_info.get('distribution', 'opensearch')
        
        # Parse semantic version
        parts = version_string.split('.')
        major = int(parts[0]) if len(parts) > 0 else 0
        minor = int(parts[1]) if len(parts) > 1 else 0
        patch = int(parts[2]) if len(parts) > 2 else 0
        
        return {
            'version_string': version_string,
            'distribution': distribution,
            'major_version': major,
            'minor_version': minor,
            'patch_version': patch,
            'is_v1_or_newer': major >= 1,
            'is_v1_3_or_newer': major > 1 or (major == 1 and minor >= 3),
            'is_v2_or_newer': major >= 2,
            'is_v2_4_or_newer': major > 2 or (major == 2 and minor >= 4),
            'is_v2_9_or_newer': major > 2 or (major == 2 and minor >= 9),
            'is_v2_11_or_newer': major > 2 or (major == 2 and minor >= 11),
        }
    except Exception as e:
        logger.warning(f"Could not detect OpenSearch version: {e}")
        return {
            'version_string': 'Unknown',
            'distribution': 'unknown',
            'major_version': 0,
            'is_v1_or_newer': False,
            'is_v2_or_newer': False,
        }
----

**Key Milestones:**
- **OpenSearch 1.0+**: Fork from Elasticsearch 7.10.2
- **OpenSearch 1.3+**: Observability features, trace analytics
- **OpenSearch 2.0+**: Segment replication, remote-backed storage
- **OpenSearch 2.4+**: Query insights, search pipelines
- **OpenSearch 2.9+**: Concurrent segment search
- **OpenSearch 2.11+**: Derived fields, improved query performance

===== Kafka

**Version String Formats:**
- Kafka doesn't expose server version directly via API
- Must infer from broker API versions or configuration

**Implementation:**
[source,python]
----
def _get_version_info(self):
    """Detects Kafka cluster information."""
    try:
        cluster = self.admin_client._client.cluster
        brokers = list(cluster.brokers())
        broker_count = len(brokers) if brokers else 0
        
        # Try to get version from broker node
        version_string = "Unknown"
        if brokers:
            first_broker = brokers[0]
            # Kafka broker nodes may have version attribute
            if hasattr(first_broker, 'version'):
                version_string = str(first_broker.version)
        
        # Parse if we got a version
        major = 0
        if version_string != "Unknown":
            import re
            match = re.match(r'(\d+)\.(\d+)', version_string)
            if match:
                major = int(match.group(1))
        
        return {
            'version_string': version_string,
            'broker_count': broker_count,
            'major_version': major,
            'is_v2_or_newer': major >= 2,
            'is_v2_6_or_newer': major > 2 or (major == 2 and '2.6' in version_string),
            'is_v3_or_newer': major >= 3,
            'is_v4_or_newer': major >= 4,
        }
    except Exception as e:
        logger.warning(f"Could not detect Kafka version: {e}")
        return {
            'version_string': 'Unknown',
            'broker_count': 0,
            'major_version': 0,
            'is_v2_or_newer': False,
            'is_v3_or_newer': False,
            'is_v4_or_newer': False,
        }
----

**Key Milestones:**
- **Kafka 2.6+**: Improved KRaft (ZooKeeper replacement) support
- **Kafka 3.0+**: Deprecated ZooKeeper mode
- **Kafka 3.3+**: KRaft production ready
- **Kafka 4.0+**: Removed ZooKeeper support entirely
- **Kafka 4.1+**: Enhanced tiered storage

===== Redis/Valkey

**Version String Formats:**
- `"7.2.4"`
- `"7.0.15"`
- `"6.2.14"`
- Valkey: `"7.2.5"` (fork maintains version compatibility)

**Implementation:**
[source,python]
----
def _get_version_info(self):
    """Detects Redis/Valkey version."""
    try:
        info = self.client.info('server')
        version_string = info.get('redis_version', 'Unknown')
        
        # Parse semantic version
        parts = version_string.split('.')
        major = int(parts[0]) if len(parts) > 0 else 0
        minor = int(parts[1]) if len(parts) > 1 else 0
        patch = int(parts[2]) if len(parts) > 2 else 0
        
        return {
            'version_string': version_string,
            'major_version': major,
            'minor_version': minor,
            'patch_version': patch,
            'is_v6_or_newer': major >= 6,
            'is_v6_2_or_newer': major > 6 or (major == 6 and minor >= 2),
            'is_v7_or_newer': major >= 7,
            'is_v7_2_or_newer': major > 7 or (major == 7 and minor >= 2),
        }
    except Exception as e:
        logger.warning(f"Could not detect Redis/Valkey version: {e}")
        return {
            'version_string': 'Unknown',
            'major_version': 0,
            'is_v6_or_newer': False,
            'is_v7_or_newer': False,
        }
----

**Key Milestones:**
- **Redis 6.0+**: ACLs, SSL/TLS, client-side caching
- **Redis 6.2+**: LTS release, improved eviction
- **Redis 7.0+**: Redis Functions, sharded pub/sub
- **Redis 7.2+**: Enhanced query capabilities
- **Valkey 7.2+**: AWS fork, API-compatible with Redis

===== MySQL/MariaDB

**Version String Formats:**
- MySQL: `"8.0.35"`
- MySQL: `"5.7.44"`
- MariaDB: `"10.11.6-MariaDB"`
- MariaDB: `"11.2.2-MariaDB"`

**Implementation:**
[source,python]
----
def _get_version_info(self):
    """Detects MySQL/MariaDB version."""
    try:
        self.cursor.execute("SELECT VERSION();")
        version_string = self.cursor.fetchone()[0]
        
        is_mariadb = 'MariaDB' in version_string
        
        # Parse version number
        import re
        match = re.match(r'(\d+)\.(\d+)\.(\d+)', version_string)
        if match:
            major = int(match.group(1))
            minor = int(match.group(2))
            patch = int(match.group(3))
        else:
            major, minor, patch = 0, 0, 0
        
        if is_mariadb:
            return {
                'version_string': version_string,
                'distribution': 'MariaDB',
                'major_version': major,
                'minor_version': minor,
                'patch_version': patch,
                'is_mariadb_10_or_newer': major >= 10,
                'is_mariadb_10_6_or_newer': major > 10 or (major == 10 and minor >= 6),
                'is_mariadb_10_11_or_newer': major > 10 or (major == 10 and minor >= 11),
                'is_mariadb_11_or_newer': major >= 11,
            }
        else:
            return {
                'version_string': version_string,
                'distribution': 'MySQL',
                'major_version': major,
                'minor_version': minor,
                'patch_version': patch,
                'is_mysql_5_7_or_newer': major > 5 or (major == 5 and minor >= 7),
                'is_mysql_8_or_newer': major >= 8,
                'is_mysql_8_0_or_newer': major > 8 or (major == 8 and minor >= 0),
            }
    except Exception as e:
        logger.warning(f"Could not detect MySQL/MariaDB version: {e}")
        return {
            'version_string': 'Unknown',
            'distribution': 'Unknown',
            'major_version': 0,
            'is_mysql_8_or_newer': False,
        }
----

**Key Milestones:**
- **MySQL 5.7+**: JSON support, generated columns
- **MySQL 8.0+**: Window functions, CTEs, roles, data dictionary
- **MariaDB 10.6+**: Atomic DDL, system-versioned tables
- **MariaDB 10.11+**: LTS release
- **MariaDB 11.x+**: Improved performance, new features

==== Usage in Health Checks

Health checks should use version flags for conditional logic:

[source,python]
----
def run_my_check(connector, settings):
    version = connector.version_info
    
    # Use version-specific queries or features
    if version['is_pg14_or_newer']:
        # Use PostgreSQL 14+ features
        query = "SELECT ... FROM pg_stat_statements WHERE ..."
    else:
        # Fallback for older versions
        query = "SELECT ... FROM pg_stat_activity WHERE ..."
    
    # Execute with appropriate query
    results = connector.execute_query(query, return_raw=True)
----

==== Best Practices

1. **Always provide fallback values** in exception handlers
2. **Use boolean flags** for readability (not `>=` comparisons in checks)
3. **Cache version info** via `@property` decorator
4. **Log warnings** when version detection fails
5. **Include major milestones** as boolean flags based on technology roadmap
6. **Parse conservatively** - assume older version if parsing fails
7. **Document key milestones** in comments for future maintainers

==== Edge Cases to Handle

1. **Unknown version strings**: Return safe defaults (version 0, all flags False)
2. **Beta/RC versions**: Parse numeric portion, ignore suffixes
3. **Custom builds**: May have additional text after version number
4. **Forked distributions**: Detect distribution type (e.g., MariaDB vs MySQL)
5. **Version API changes**: Wrap in try/except, provide fallbacks
